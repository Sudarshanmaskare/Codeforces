//Author : @Sudarshan_Believe_that(Rega)
// `ctrl+alt+f`: Format current file.
// `ctrl+b`: build and run current file.
//Most of problems soln := Should have faith in recursive calls:)
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update
using namespace std;
#define pb                push_back
#define ppb               pop_back
#define pf                push_front
#define ppf               pop_front
#define all(x)            (x).begin(),(x).end()
#define uniq(v)           (v).erase(unique(all(v)),(v).end())
#define sz(x)             (int)((x).size())
#define fr                first
#define sc                second
#define pii               pair<int,int>
#define rep(i,a,b)        for(int i=a;i<b;i++)
#define mem1(a)           memset(a,-1,sizeof(a))
#define mem0(a)           memset(a,0,sizeof(a))
#define ar array
#define ll long long
#define ld long double
enum State { q0, q1, q2, qd };//use carefully
const int MAX_N = 1e5 + 5;
const ll MOD = 1e9 + 7;
const ll INF = 1e9;
const ld EPS = 1e-9;// sort(d.begin(),d.end());// d.erase(unique(d.begin(),d.end()),d.end()); remove continuous elements
long long int power_mod(long long int x, long long int y, long long int p) {long long int res = 1ll; x = x % p; if (x == 0)return 0; while (y > 0) {if (y & 1)res = (res * x) % p; y = y >> 1; x = (x * x) % p;} return res;}
vector<int> maxSubMatrixSumQueries(vector<int> mat[], int n, int m, vector<pair<int, int>> &queries, int q) {
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0)); for (int i = 1; i <= n; i++) {for (int j = 1; j <= m; j++) {dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];}} vector<int> ans;
    for (auto var : queries) {int maxi = 0, k = var.first, l = var.second; for (int i = k; i <= n; i++) {for (int j = l; j <= m; j++) {int temp = dp[i][j] - dp[i - k][j] - dp[i][j - l] + dp[i - k][j - l]; maxi = max(maxi, temp);}} ans.push_back(maxi);} return ans;
}
//(a+b)%d=0 then a%d=(d-b%d)%d
//function<void(Tree*, int)> traverse = [&](Tree* root, int lv){}; syntax for lmbada (nice encapsulated code)
struct TreeNode {
    int data; TreeNode *left, *right; TreeNode(int x) {left = right = NULL; data = x;}
};
//(Bestexample to learn pointers) int a = 4;int *b = &a;cout << &(*b)0x13ffde4 << "\n";int **c = &b;cout << &(**c)0x13ffde4<<" " << &(*c)0x13ffdd8;
void SieveOfEratosthenes(int N) {
    bool check[N + 1]; memset(check, true, sizeof(check)); vector<int> prime;
    for (int p = 2; p * p <= N; p++) {if (check[p] == true) {prime.push_back(p); for (int i = p * p; i <= N; i += p)check[i] = false;}}
}
int parent_dsu[100000]; int rank_dsu[100000];
void set_dsu(int n) {
    for (int i = 0; i <= n; i++) {parent_dsu[i] = i; rank_dsu[i] = 0;}
}
int findpar_dsu(int node) {
    if (node == parent_dsu[node]) return node; return parent_dsu[node] = findpar_dsu(parent_dsu[node]);
}
void union_dsu(int u, int v) {
    int parent_u = findpar_dsu(u); int parent_v = findpar_dsu(v); if (rank_dsu[parent_u] < rank_dsu[parent_v]) {parent_dsu[parent_u] = parent_v;} else if (rank_dsu[parent_u] > rank_dsu[parent_v]) {parent_dsu[parent_v] = parent_u;} else {parent_dsu[u] = parent_v; rank_dsu[parent_v]++;}
}
void judge() {
#ifndef ONLINE_JUDGE
    freopen("input_cp.txt", "r", stdin); freopen("output_cp.txt", "w", stdout);
#endif
}
void fast() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
}
//////////////////////////////////////////////////////code below//////////////////////////////////////////////////////////

// string multiply(string num1, string num2) {
//     int m = num1.size(), n = num2.size();
//     string ans(m + n, '0');
//     for (int i = m - 1; i >= 0; i--) {
//         for (int j = n - 1; j >= 0; j--) {
//             int sum = (num1[i] - '0') * (num2[j] - '0') + (ans[i + j + 1] - '0');
//             ans[i + j + 1] = sum % 10 + '0';
//             ans[i + j] += sum / 10;
//         }

//     }
//     for (int i = 0; i < m + n; i++) {
//         if (ans[i] != '0') {
//             return ans.substr(i);
//         }
//     }
//     return "0";
// }
// std::rotate(v.begin(), v.begin() + v.size() - k, v.end()); //right rotation
// std::rotate(v.begin(), v.begin() + k, v.end()); //left rotation
// int bs_lower_bound(int a[], int n, int x) {
//     int l = 0;
//     int h = n; // Not n - 1
//     while (l < h) {
//         int mid =  l + (h - l) / 2;
//         if (x <= a[mid]) {
//             h = mid;
//         } else {
//             l = mid + 1;
//         }
//     }
//     return l;
// }





void solve() {

   

}
int main() {
    //execution starts
    fast();//fast execution
    judge();//Judge
    solve();//Heart
    return 0;
}


